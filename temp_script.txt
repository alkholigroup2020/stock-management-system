// Code examples
const codeExamples = {
  serverErrorBasic: `import prisma from "../../utils/prisma";

export default defineEventHandler(async (event) => {
  const user = event.context.user;

  if (!user) {
    throw createError({
      statusCode: 401,
      statusMessage: "Unauthorized",
      data: {
        code: "NOT_AUTHENTICATED",
        message: "You must be logged in to access this resource",
      },
    });
  }

  const itemId = getRouterParam(event, "id");

  if (!itemId) {
    throw createError({
      statusCode: 400,
      statusMessage: "Bad Request",
      data: {
        code: "MISSING_PARAMETER",
        message: "Item ID is required",
      },
    });
  }

  const item = await prisma.item.findUnique({
    where: { id: itemId },
  });

  if (!item) {
    throw createError({
      statusCode: 404,
      statusMessage: "Not Found",
      data: {
        code: "ITEM_NOT_FOUND",
        message: "Item not found",
      },
    });
  }

  return { item };
});`,

  serverErrorAdvanced: `export default defineEventHandler(async (event) => {
  try {
    const body = await readBody(event);
    const data = bodySchema.parse(body);

    // Check stock availability
    const stock = await prisma.locationStock.findUnique({
      where: {
        location_id_item_id: {
          location_id: data.location_id,
          item_id: data.item_id,
        },
      },
    });

    if (!stock || stock.on_hand < data.quantity) {
      throw createError({
        statusCode: 400,
        statusMessage: "Bad Request",
        data: {
          code: "INSUFFICIENT_STOCK",
          message: "Not enough stock available",
          details: {
            insufficient_items: [
              {
                item_id: data.item_id,
                item_name: item.name,
                requested: data.quantity,
                available: stock?.on_hand || 0,
              },
            ],
          },
        },
      });
    }

    // Perform operation...
    return { success: true };
  } catch (error) {
    // Handle Zod validation errors
    if (error instanceof z.ZodError) {
      throw createError({
        statusCode: 400,
        statusMessage: "Bad Request",
        data: {
          code: "VALIDATION_ERROR",
          message: "Invalid request data",
          details: {
            errors: error.issues.map((issue) => ({
              path: issue.path,
              message: issue.message,
            })),
          },
        },
      });
    }

    // Re-throw createError errors
    if (error && typeof error === "object" && "statusCode" in error) {
      throw error;
    }

    // Generic server error
    console.error("Error processing request:", error);
    throw createError({
      statusCode: 500,
      statusMessage: "Internal Server Error",
      data: {
        code: "INTERNAL_ERROR",
        message: "Failed to process request",
        details: error instanceof Error ? error.message : "Unknown error",
      },
    });
  }
});`,

  clientErrorBasic: `<script setup lang="ts">
const { handleError, handleSuccess } = useErrorHandler();

const deleteItem = async (itemId: string) => {
  try {
    await $fetch(\`/api/items/\${itemId}\`, {
      method: "DELETE",
    });

    handleSuccess("Item Deleted", {
      description: "The item has been deleted successfully",
    });

    // Refresh data or redirect
    await refreshData();
  } catch (error) {
    handleError(error, { context: "deleting item" });
  }
};
</script>
`,

  clientErrorAdvanced: `<script setup lang="ts">
const { handleError, handleSuccess, getErrorMessage } = useErrorHandler();

const formData = reactive({
  supplier_id: "",
  invoice_no: "",
  lines: [],
});

const posting = ref(false);
const showPostConfirmation = ref(false);

const postDelivery = async () => {
  // Validate form
  if (!formData.supplier_id || !formData.invoice_no) {
    handleError({
      data: {
        code: "VALIDATION_ERROR",
        message: "Please fill in all required fields",
      },
    });
    return;
  }

  posting.value = true;

  try {
    const response = await $fetch("/api/locations/:id/deliveries", {
      method: "POST",
      body: { ...formData, status: "POSTED" },
    });

    handleSuccess("Delivery Posted", {
      description: response.message || "Delivery posted successfully",
    });

    // Invalidate caches
    await refreshNuxtData(["deliveries", "stock"]);

    // Redirect
    navigateTo("/deliveries");
  } catch (error) {
    // Custom handling for specific errors
    const errorMsg = getErrorMessage(error);

    if (errorMsg.title === "Insufficient Stock") {
      // Show custom modal or special handling
      showStockErrorDialog.value = true;
    }

    handleError(error, { context: "posting delivery" });
  } finally {
    posting.value = false;
    showPostConfirmation.value = false;
  }
};
</script>`,

  toastBasic: `<script setup lang="ts">
const toast = useAppToast();

// Success notification
const onSave = () => {
  toast.success("Item Saved", {
    description: "The item has been saved successfully",
  });
};

// Error notification
const onError = () => {
  toast.error("Failed to Save", {
    description: "An error occurred while saving the item",
  });
};

// Warning notification
const onWarning = () => {
  toast.warning("Low Stock", {
    description: "This item is running low on stock",
  });
};

// Info notification
const onInfo = () => {
  toast.info("Period Closing", {
    description: "The current period will close in 2 days",
  });
};
</script>`,

  toastAdvanced: `<script setup lang="ts">
const toast = useAppToast();

// Toast with custom icon
toast.success("Transfer Approved", {
  description: "The transfer has been approved and is ready for execution",
  icon: "i-lucide-check-circle-2",
  duration: 6000,
});

// Toast with actions
toast.info("New NCR Created", {
  description: "A price variance NCR has been automatically created",
  actions: [
    {
      label: "View NCR",
      click: () => {
        navigateTo(\`/ncrs/\${ncrId}\`);
      },
    },
  ],
});

// Clear all toasts
toast.clear();
</script>`,

  typeGuards: `/**
 * Type guard for H3 error format (from Nuxt server)
 */
export function isH3Error(error: unknown): error is {
  statusCode: number;
  statusMessage: string;
  data: {
    code?: string;
    message?: string;
    details?: unknown;
  };
} {
  return (
    error !== null &&
    typeof error === "object" &&
    "statusCode" in error &&
    "data" in error &&
    typeof (error as any).data === "object"
  );
}

/**
 * Type guard for Zod validation errors
 */
export function isZodError(error: unknown): error is z.ZodError {
  return error instanceof z.ZodError;
}

/**
 * Type guard for standard Error objects
 */
export function isError(error: unknown): error is Error {
  return error instanceof Error;
}

// Usage example
try {
  await $fetch("/api/items", { method: "POST", body: data });
} catch (error) {
  if (isH3Error(error)) {
    // TypeScript knows error has statusCode, data, etc.
    console.error(error.data.code, error.data.message);
  } else if (isError(error)) {
    // TypeScript knows error has message property
    console.error(error.message);
  } else {
    // Unknown error type
    console.error("Unknown error:", error);
  }
}`,

  validationErrors: `<script setup lang="ts">
import { z } from "zod";

// Define validation schema
const itemSchema = z.object({
  code: z
    .string()
    .min(1, "Item code is required")
    .max(50, "Item code must be 50 characters or less"),
  name: z
    .string()
    .min(1, "Item name is required")
    .max(200, "Item name must be 200 characters or less"),
  unit: z.enum(["KG", "EA", "LTR", "BOX", "CASE", "PACK"], {
    errorMap: () => ({ message: "Please select a valid unit" }),
  }),
});

// Form state
const form = reactive({
  code: "",
  name: "",
  unit: undefined as string | undefined,
});

const errors = reactive({
  code: "",
  name: "",
  unit: "",
});

// Field-level validation
function validateField(field: keyof typeof form) {
  try {
    const fieldSchema = itemSchema.shape[field];
    if (fieldSchema) {
      fieldSchema.parse(form[field]);
      errors[field] = "";
    }
  } catch (error) {
    if (error instanceof z.ZodError) {
      errors[field] = error.issues[0]?.message || "Invalid value";
    }
  }
}

// Form-level validation
function validateForm(): boolean {
  try {
    itemSchema.parse(form);

    // Clear all errors
    Object.keys(errors).forEach((key) => {
      errors[key as keyof typeof errors] = "";
    });

    return true;
  } catch (error) {
    if (error instanceof z.ZodError) {
      // Set errors for each field
      error.issues.forEach((err) => {
        const field = err.path[0] as keyof typeof errors;
        if (field) {
          errors[field] = err.message;
        }
      });
    }
    return false;
  }
}
</script>

<template>
  <div>
    <UInput
      v-model="form.code"
      :error="!!errors.code"
      @blur="validateField('code')"
    />
    <p v-if="errors.code" class="mt-1 text-caption text-[var(--ui-error)]">
      {{ errors.code }}
    </p>
  </div>
</template>`,

  networkErrors: `<script setup lang="ts">
const { handleError } = useErrorHandler();
const { isOnline } = useOnlineStatus();

const fetchData = async () => {
  // Check online status first
  if (!isOnline.value) {
    handleError({
      data: {
        code: "NETWORK_ERROR",
        message: "You are offline. Please check your connection.",
      },
    });
    return;
  }

  try {
    const data = await $fetch("/api/items");
    return data;
  } catch (error) {
    // Network errors typically have no response
    if (!error || typeof error !== "object" || !("statusCode" in error)) {
      handleError({
        data: {
          code: "NETWORK_ERROR",
          message: "Unable to connect to the server",
        },
      });
    } else {
      handleError(error, { context: "fetching items" });
    }
  }
};
</script>`,

  offlineGuard: `<script setup lang="ts">
const { isOnline, guardAction, checkOnline } = useOfflineGuard();

// Wrap async actions to guard against offline execution
const handleSubmit = async () => {
  await guardAction(async () => {
    await $fetch("/api/deliveries", {
      method: "POST",
      body: formData,
    });

    handleSuccess("Delivery Created");
  }, {
    offlineMessage: "Cannot create delivery",
    offlineDescription: "You need to be online to create a delivery",
  });
};

// Synchronous check before starting an action
const startProcess = () => {
  if (!checkOnline()) {
    return; // Toast already shown by checkOnline
  }

  // Continue with the process
  showModal.value = true;
};
</script>

<template>
  <div>
    <!-- Disable button when offline -->
    <UButton
      :disabled="!isOnline"
      class="cursor-pointer"
      @click="handleSubmit"
    >
      Submit
    </UButton>
  </div>
</template>`,

  apiErrorHandling: `// server/api/items/[id].patch.ts
export default defineEventHandler(async (event) => {
  try {
    const itemId = getRouterParam(event, "id");
    const body = await readBody(event);

    // Validate request
    const data = updateItemSchema.parse(body);

    // Check item exists
    const item = await prisma.item.findUnique({
      where: { id: itemId },
    });

    if (!item) {
      throw createError({
        statusCode: 404,
        statusMessage: "Not Found",
        data: {
          code: "ITEM_NOT_FOUND",
          message: "Item not found",
        },
      });
    }

    // Check for duplicate code
    if (data.code && data.code !== item.code) {
      const existing = await prisma.item.findFirst({
        where: { code: data.code },
      });

      if (existing) {
        throw createError({
          statusCode: 409,
          statusMessage: "Conflict",
          data: {
            code: "DUPLICATE_CODE",
            message: "An item with this code already exists",
          },
        });
      }
    }

    // Update item
    const updated = await prisma.item.update({
      where: { id: itemId },
      data,
    });

    return {
      message: "Item updated successfully",
      item: updated,
    };
  } catch (error) {
    // Handle Zod validation errors
    if (error instanceof z.ZodError) {
      throw createError({
        statusCode: 400,
        statusMessage: "Bad Request",
        data: {
          code: "VALIDATION_ERROR",
          message: "Invalid request data",
          details: {
            errors: error.issues,
          },
        },
      });
    }

    // Re-throw createError errors
    if (error && typeof error === "object" && "statusCode" in error) {
      throw error;
    }

    // Log and return generic error
    console.error("Error updating item:", error);
    throw createError({
      statusCode: 500,
      statusMessage: "Internal Server Error",
      data: {
        code: "INTERNAL_ERROR",
        message: "Failed to update item",
      },
    });
  }
});`,

  errorCodes: `/**
 * Standard Error Codes
 *
 * These error codes are used throughout the application for consistent
 * error handling and user-friendly messages.
 */

// Stock/Inventory Errors
INSUFFICIENT_STOCK          // Not enough stock for operation
NEGATIVE_STOCK_NOT_ALLOWED  // Operation would result in negative stock

// Location Errors
LOCATION_ACCESS_DENIED      // User lacks access to location
LOCATION_NOT_FOUND          // Location doesn't exist
SAME_LOCATION               // Source and destination are the same

// Period Errors
PERIOD_CLOSED               // Cannot modify closed period
PERIOD_NOT_READY            // Not all locations ready for close
NO_OPEN_PERIOD              // No open period exists

// Price Errors
PRICE_VARIANCE              // Price differs from locked period price

// Validation Errors
VALIDATION_ERROR            // General validation error
REQUIRED_FIELD              // Required field missing

// Permission Errors
PERMISSION_DENIED           // User lacks permission
UNAUTHORIZED                // Not authenticated or session expired

// Approval Errors
APPROVAL_REQUIRED           // Action requires approval
ALREADY_APPROVED            // Already approved
ALREADY_REJECTED            // Already rejected

// Network/Server Errors
NETWORK_ERROR               // Cannot connect to server
SERVER_ERROR                // Server-side error
TIMEOUT                     // Request timeout

// Database Errors
DUPLICATE_ENTRY             // Record already exists
NOT_FOUND                   // Resource not found

// Business Logic Errors
INVALID_STATUS_TRANSITION   // Invalid status change`,
};
</script>
